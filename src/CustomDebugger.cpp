#include <CustomDebugger.h>
#pragma comment(lib, "dbghelp.lib")
#include "Common.h"//DEBUG_BREAKPOINT()

namespace MYCRT {
	MemoryDebugger* MemoryDebugger::s_instance = nullptr;
	int MemoryDebuggerInitializer::s_count = 0;

	// Constructor
	MemoryDebuggerInitializer::MemoryDebuggerInitializer()
	{
		if (++s_count == 1)
		{
			MemoryDebugger::s_instance = static_cast<MemoryDebugger*>(malloc(sizeof(MemoryDebugger)));
			MemoryDebugger::s_instance = new (MemoryDebugger::s_instance) MemoryDebugger; // Placement new
		}
	}

	// Destructor
	MemoryDebuggerInitializer::~MemoryDebuggerInitializer()
	{
		if (--s_count == 0)
		{
			MemoryDebugger::s_instance->~MemoryDebugger();
			free(MemoryDebugger::s_instance);
		}
	}

	void* MemoryDebugger::PageAlignedAllocate(size_t size) {
		AllocInfo allocInfo;
		size_t numPages = 2;
		if (size > 0) {
			numPages = size / PAGE_SIZE + (size % PAGE_SIZE == 0 ? 1 : 2);
		}
		allocInfo.basePtr = VirtualAlloc(0, numPages * PAGE_SIZE, MEM_RESERVE, PAGE_NOACCESS);
		if (allocInfo.basePtr == nullptr) {
			return nullptr;//can't alloc
		}
		allocInfo.basePtr = VirtualAlloc(allocInfo.basePtr, (numPages - 1) * PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);
		allocInfo.ptr = (unsigned char*)allocInfo.basePtr + (numPages - 1) * PAGE_SIZE - size;
		allocated_list.push_back(allocInfo);
		return allocInfo.ptr;
	}

	// Set the size parameter to 0 to resolve warnings generated by a non-zero value with the MEM_DECOMMIT flag.
	bool MemoryDebugger::Deallocate(void* basePtr) {
		return VirtualFree(basePtr, 0, MEM_DECOMMIT);
	}

	// Set the size parameter to 0 per Microsoft's documentation when using the MEM_RELEASE flag.
	bool MemoryDebugger::Release(void* address) {
		return VirtualFree(address, 0, MEM_RELEASE);
	}
	void MemoryDebugger::SymbolsInit() {
		SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);
		SymInitialize(GetCurrentProcess(), nullptr, true);
	}

	MemoryDebugger::~MemoryDebugger() {
		FILE* fp;
		errno_t err;
		if ((err = fopen_s(&fp, "DebugLog.csv", "w")) == 0) {
			fprintf(fp, "Message, File, Line, Bytes, Address, Additional Info\n");
		}
		for (auto itr = allocated_list.begin(); itr != allocated_list.end(); ++itr) {
			//Message, File, Line, Bytes, Address, Additional Info
			if (fp) {
				if (itr->ptr != nullptr) {//if not deallocated
					fprintf(fp, "Memory Leak, ");
					IMAGEHLP_LINE64 line = GetSymbols(itr->rip);
					fprintf(fp, "%s , %lu, %I64u, 0x%p, Instruction Pointer=  0x%p\n", line.FileName, line.LineNumber, itr->size, itr->ptr, (void*)itr->rip);
				}
			}
			VirtualFree(itr->basePtr, 0, MEM_RELEASE);
		}
		if (fp) {
			fclose(fp);
		}
	}
	IMAGEHLP_LINE64 MemoryDebugger::GetSymbols(DWORD64 returnAddress) {
		SymSetOptions(SYMOPT_LOAD_LINES);
		IMAGEHLP_LINE64 line;
		line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
		DWORD displacement;

		if (!SymGetLineFromAddr64(GetCurrentProcess(), returnAddress, &displacement, &line)) {
			DWORD error = GetLastError();
			printf("SymGetLineFromAddr64 returned error : %d\n", error);
		}
		return line;
	}
	void MemoryDebugger::InitSym() {
		// Only initialize once
		static bool ImghelpInitilized = false;
		if (ImghelpInitilized) { return; }

		// Initilize IMAGEHLP.DLL
		SymInitialize(GetCurrentProcess(), NULL, true);
		ImghelpInitilized = true;
	}

	// Print the call stack entry for the given address
	void MemoryDebugger::ObserveMemory(size_t size, OperatorType allocType) {

		CONTEXT context;
		AllocInfo& allocInfo = allocated_list.back();
		RtlCaptureContext(&context);
		allocInfo.size = size;
		allocInfo.rip = StackTrace(&context);
		allocInfo.opType = allocType;
	}

	void MemoryDebugger::FillStackFrame(STACKFRAME64& stack_frame, const CONTEXT& context) {
		stack_frame.AddrPC.Mode = AddrModeFlat;
		stack_frame.AddrPC.Offset = context.Rip;
		stack_frame.AddrStack.Mode = AddrModeFlat;
		stack_frame.AddrStack.Offset = context.Rsp;
		stack_frame.AddrFrame.Mode = AddrModeFlat;
		stack_frame.AddrFrame.Offset = context.Rbp;
	}

	DWORD64 MemoryDebugger::StackTrace(const CONTEXT* start_context) {
		InitSym();

		// Fill the initial context information
		CONTEXT context = *start_context;

		// Fill the initial stack frame information
		STACKFRAME64 stack_frame = { 0 };
		FillStackFrame(stack_frame, context);

		for (int i = 0; i < NUM_INTERNAL_CALLS; ++i) {
			// Find the caller's parent
			BOOL result = StackWalk64(
				IMAGE_FILE_MACHINE_AMD64,
				GetCurrentProcess(), // Process
				GetCurrentThread(), // Thread
				&stack_frame, // Stack Frame Information
				&context, // Thread Context Information
				NULL, // Read Memory Call Back (Not Used)
				SymFunctionTableAccess64, // Function Table Accessor
				SymGetModuleBase64, // Module Base Accessor
				NULL); // Address Translator (Not Used)
			if (result == FALSE) { break; }
		}
		return stack_frame.AddrReturn.Offset;
	}

	bool MemoryDebugger::MemoryDeallocated(DWORD64& memory, OperatorType deleteType) {
		for (std::list<AllocInfo>::iterator itr = allocated_list.begin(); itr != allocated_list.end(); ++itr) {
			if (itr->ptr == (unsigned char*)memory) {
				if (AreTypesMatching(itr->opType, deleteType) == false) {
					break;
				}
				if (Deallocate(itr->basePtr) == true) {
					itr->ptr = nullptr;
					return true;
				}
				break;
			}
		}
		return false;
	}
	bool AreTypesMatching(OperatorType allocType, OperatorType deallocType) {
		if (allocType == OperatorType::NEW && deallocType == OperatorType::DEL
			|| allocType == OperatorType::NEW_ARRAY && deallocType == OperatorType::DEL_ARRAY) {
			return true;
		}
		return false;
	}
}

void* operator new(size_t size) {
	void* memory = MYCRT::MemoryDebugger::s_instance->PageAlignedAllocate(size);
	if (memory == nullptr) {
		throw std::bad_alloc{};
	}
	MYCRT::MemoryDebugger::s_instance->ObserveMemory(size, MYCRT::OperatorType::NEW);
	return memory;
}
void* operator new(size_t size, const std::nothrow_t) noexcept {
	void* memory = MYCRT::MemoryDebugger::s_instance->PageAlignedAllocate(size);
	if (memory != nullptr) {
		MYCRT::MemoryDebugger::s_instance->ObserveMemory(size, MYCRT::OperatorType::NEW);
	}
	return memory;
}
void* operator new[](size_t size) {
	void* memory = MYCRT::MemoryDebugger::s_instance->PageAlignedAllocate(size);
	if (memory == nullptr) {
		throw std::bad_alloc{};
	}
	MYCRT::MemoryDebugger::s_instance->ObserveMemory(size, MYCRT::OperatorType::NEW_ARRAY);
	return memory;
}
void* operator new[](size_t size, const std::nothrow_t&) noexcept {
	void* memory = MYCRT::MemoryDebugger::s_instance->PageAlignedAllocate(size);
	if (memory != nullptr) {
		MYCRT::MemoryDebugger::s_instance->ObserveMemory(size, MYCRT::OperatorType::NEW_ARRAY);
	}
	return memory;
}
void operator delete(void* address) noexcept {
	if (address == nullptr) {
		return;
	}
	if (MYCRT::MemoryDebugger::s_instance->MemoryDeallocated((DWORD64&)address, MYCRT::OperatorType::DEL) == false) {
		DEBUG_BREAKPOINT();
	}
}
void operator delete(void* address, [[maybe_unused]] size_t size) noexcept {
	if (address == nullptr) {
		return;
	}
	if (MYCRT::MemoryDebugger::s_instance->MemoryDeallocated((DWORD64&)address, MYCRT::OperatorType::DEL) == false) {
		DEBUG_BREAKPOINT();
	}
}
void operator delete(void* address, const std::nothrow_t) noexcept {
	if (address == nullptr) {
		return;
	}
	if (MYCRT::MemoryDebugger::s_instance->MemoryDeallocated((DWORD64&)address, MYCRT::OperatorType::DEL) == false) {
		DEBUG_BREAKPOINT();
	}
}
void operator delete[](void* address) noexcept {
	if (address == nullptr) {
		return;
	}
	if (MYCRT::MemoryDebugger::s_instance->MemoryDeallocated((DWORD64&)address, MYCRT::OperatorType::DEL_ARRAY) == false) {
		DEBUG_BREAKPOINT();
	}
}
void operator delete[](void* address, [[maybe_unused]] size_t size) noexcept {
	if (address == nullptr) {
		return;
	}
	if (MYCRT::MemoryDebugger::s_instance->MemoryDeallocated((DWORD64&)address, MYCRT::OperatorType::DEL_ARRAY) == false) {
		DEBUG_BREAKPOINT();
	}
}
void operator delete[](void* address, const std::nothrow_t) noexcept {
	if (address == nullptr) {
		return;
	}
	if (MYCRT::MemoryDebugger::s_instance->MemoryDeallocated((DWORD64&)address, MYCRT::OperatorType::DEL_ARRAY) == false) {
		DEBUG_BREAKPOINT();
	}
}